diff --git a/src/components/ar/ARView.tsx b/src/components/ar/ARView.tsx
index d8574e7..d0edff2 100644
--- a/src/components/ar/ARView.tsx
+++ b/src/components/ar/ARView.tsx
@@ -7,6 +7,9 @@ import { GeoObject } from '../../types/game';
 import ARDroneModel from './ARDroneModel';
 import GeoObjectNode from './GeoObjectNode';
 import { geoObjectManager } from '../../services/GeoObjectManager';
+import { calculateDistance } from '../../utils/maths';
+
+const MAX_GEOOBJECT_DISTANCE = 25; // Maximum distance in meters
 
 interface ARViewProps {
   drones?: DroneData[];
@@ -28,6 +31,18 @@ const ARView: React.FC<ARViewProps> = ({
   const controlsRef = useRef<DeviceOrientationControls>();
   const animationFrameIdRef = useRef<number>();
   const { location, heading } = useLocationContext();
+  const geoObjectRefs = useRef<Map<string, THREE.Object3D>>(new Map());
+
+  // Filter GeoObjects based on initial distance
+  const visibleGeoObjects = useMemo(() => {
+    if (!location) return [];
+
+    return geoObjects.filter((geoObject) => {
+      const distance = calculateDistance(location, geoObject.coordinate);
+      console.log(`Distance to ${geoObject.id}: ${distance}m`);
+      return distance <= MAX_GEOOBJECT_DISTANCE;
+    });
+  }, [geoObjects, location]);
 
   useEffect(() => {
     if (!containerRef.current) return;
@@ -42,8 +57,7 @@ const ARView: React.FC<ARViewProps> = ({
       1000
     );
 
-    // Set camera at eye level but moved back
-    camera.position.set(0, 1.6, 0); // Moved back in Z to help with aiming angle
+    camera.position.set(0, 1.6, 0);
     camera.rotation.set(0, 0, 0);
     cameraRef.current = camera;
 
@@ -53,10 +67,8 @@ const ARView: React.FC<ARViewProps> = ({
     containerRef.current.appendChild(renderer.domElement);
     rendererRef.current = renderer;
 
-    // Setup controls
     controlsRef.current = new DeviceOrientationControls(camera);
 
-    // Add lighting
     const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
     scene.add(ambientLight);
 
@@ -64,7 +76,6 @@ const ARView: React.FC<ARViewProps> = ({
     directionalLight.position.set(0, 1, 0);
     scene.add(directionalLight);
 
-    // Initialize GeoObjectManager
     geoObjectManager.initialize(scene);
     geoObjectManager.setUpdateCallback((count) => {
       console.log('GeoObject count updated:', count);
@@ -73,17 +84,28 @@ const ARView: React.FC<ARViewProps> = ({
       onGeoObjectHit?.(geoObject.id);
     });
 
-    // Animation loop
+    // Animation loop with distance check
     const animate = () => {
       animationFrameIdRef.current = requestAnimationFrame(animate);
       if (controlsRef.current) {
         controlsRef.current.update();
       }
+
+      // Update visibility of all GeoObjects based on current distance
+      if (location) {
+        geoObjects.forEach((geoObject) => {
+          const object = geoObjectRefs.current.get(geoObject.id);
+          if (object) {
+            const distance = calculateDistance(location, geoObject.coordinate);
+            object.visible = distance <= MAX_GEOOBJECT_DISTANCE;
+          }
+        });
+      }
+
       renderer.render(scene, camera);
     };
     animate();
 
-    // Handle window resize
     const handleResize = () => {
       if (camera && renderer) {
         camera.aspect = window.innerWidth / window.innerHeight;
@@ -103,8 +125,27 @@ const ARView: React.FC<ARViewProps> = ({
         containerRef.current.removeChild(renderer.domElement);
       }
       renderer.dispose();
+      geoObjectRefs.current.clear();
     };
-  }, []);
+  }, [geoObjects, location]);
+
+  // Handle location updates for GeoObjects
+  useEffect(() => {
+    if (location) {
+      geoObjectManager.updatePositions(location, heading || 0);
+    }
+  }, [location, heading]);
+
+  // Register GeoObject refs for visibility tracking
+  const handleGeoObjectMounted = useCallback(
+    (id: string, object: THREE.Object3D) => {
+      geoObjectRefs.current.set(id, object);
+      return () => {
+        geoObjectRefs.current.delete(id);
+      };
+    },
+    []
+  );
 
   const raycaster = useMemo(() => new THREE.Raycaster(), []);
 
@@ -304,20 +345,6 @@ const ARView: React.FC<ARViewProps> = ({
     animateDownward();
   };
 
-  // Handle location updates for GeoObjects
-  useEffect(() => {
-    if (location) {
-      geoObjectManager.updatePositions(location, heading || 0);
-    }
-  }, [location, heading]);
-
-  // Spawn GeoObjects
-  useEffect(() => {
-    geoObjects.forEach((geoObject) => {
-      geoObjectManager.spawnGeoObject(geoObject);
-    });
-  }, [geoObjects]);
-
   // Listen for gameShoot events
   useEffect(() => {
     console.log('ARView mounted, setting up gameShoot listener');
@@ -349,13 +376,16 @@ const ARView: React.FC<ARViewProps> = ({
               camera={cameraRef.current}
             />
           ))}
-          {geoObjects.map((geoObject) => (
+          {visibleGeoObjects.map((geoObject) => (
             <GeoObjectNode
               key={geoObject.id}
               geoObject={geoObject}
               onHit={onGeoObjectHit}
               scene={sceneRef.current}
               camera={cameraRef.current}
+              onMounted={(object) =>
+                handleGeoObjectMounted(geoObject.id, object)
+              }
             />
           ))}
         </>
diff --git a/src/components/ar/GeoObjectNode.tsx b/src/components/ar/GeoObjectNode.tsx
index 5ad6e6c..0ff241a 100644
--- a/src/components/ar/GeoObjectNode.tsx
+++ b/src/components/ar/GeoObjectNode.tsx
@@ -8,6 +8,7 @@ interface GeoObjectNodeProps {
   onHit?: (id: string) => void;
   scene: THREE.Scene;
   camera: THREE.Camera;
+  onMounted?: (object: THREE.Object3D) => void;
 }
 
 const GeoObjectNode: React.FC<GeoObjectNodeProps> = ({
@@ -15,6 +16,7 @@ const GeoObjectNode: React.FC<GeoObjectNodeProps> = ({
   onHit,
   scene,
   camera,
+  onMounted,
 }) => {
   const modelRef = useRef<THREE.Group>();
   const isDestroyedRef = useRef(false);
@@ -78,11 +80,7 @@ const GeoObjectNode: React.FC<GeoObjectNodeProps> = ({
         modelRef.current = model;
         scene.add(model);
 
-        console.log('GeoObject loaded:', {
-          id: geoObject.id,
-          type: geoObject.type,
-          position: model.position,
-        });
+        onMounted?.(model);
       },
       undefined,
       (error) => console.error('Error loading geoObject model:', geoObject.type)
diff --git a/src/components/game/GameStatus.tsx b/src/components/game/GameStatus.tsx
index 9af33b6..82b258f 100644
--- a/src/components/game/GameStatus.tsx
+++ b/src/components/game/GameStatus.tsx
@@ -1,4 +1,5 @@
 import React from 'react';
+import { useLocationContext } from '../../context/LocationContext';
 
 interface GameStatusProps {
   droneCount: number;
@@ -15,6 +16,8 @@ const GameStatus: React.FC<GameStatusProps> = ({
   isOnline,
   isWebSocketConnected,
 }) => {
+  const { location } = useLocationContext();
+
   // Network status indicator
   const getConnectionColor = (isConnected: boolean) => {
     return isConnected ? 'text-green-500' : 'text-red-500';
@@ -79,6 +82,15 @@ const GameStatus: React.FC<GameStatusProps> = ({
           <path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.42 0-8-3.58-8-8s3.58-8 8-8 8 3.58 8 8-3.58 8-8 8z" />
           <circle cx="12" cy="12" r="3" />
         </svg>
+
+        {/* Location status */}
+        <svg
+          className={`w-6 h-6 ${getConnectionColor(!!location)}`}
+          viewBox="0 0 24 24"
+          fill="currentColor"
+        >
+          <path d="M12 2C8.13 2 5 5.13 5 9c0 5.25 7 13 7 13s7-7.75 7-13c0-3.87-3.13-7-7-7zM12 11.5c-1.38 0-2.5-1.12-2.5-2.5s1.12-2.5 2.5-2.5 2.5 1.12 2.5 2.5-1.12 2.5-2.5 2.5z" />
+        </svg>
       </div>
     </div>
   );
diff --git a/src/components/game/Radar.tsx b/src/components/game/Radar.tsx
index a2328bf..972bd1d 100644
--- a/src/components/game/Radar.tsx
+++ b/src/components/game/Radar.tsx
@@ -1,13 +1,12 @@
 import React, { useEffect, useRef } from 'react';
 import { useLocationContext } from '../../context/LocationContext';
 import { useGameContext } from '../../context/GameContext';
-import { LocationService } from '../../services/LocationService';
+import { calculateDistance, calculateBearing } from '../../utils/maths';
 
 const Radar = () => {
   const canvasRef = useRef<HTMLCanvasElement>(null);
   const { location, heading } = useLocationContext();
   const { geoObjects } = useGameContext();
-  const locationService = LocationService.getInstance();
 
   const RADAR_RANGE = 500; // meters
 
@@ -43,15 +42,9 @@ const Radar = () => {
         accuracy: object.coordinate.accuracy,
       };
 
-      const distance = locationService.calculateDistance(
-        location,
-        objectLocation
-      );
+      const distance = calculateDistance(location, objectLocation);
       if (distance <= RADAR_RANGE) {
-        const bearing = locationService.calculateBearing(
-          location,
-          objectLocation
-        );
+        const bearing = calculateBearing(location, objectLocation);
         const relativeAngle =
           (((heading - bearing + 360) % 360) * Math.PI) / 180;
         const normalizedDistance = distance / RADAR_RANGE;
diff --git a/src/components/map/GeoObjectMarker.tsx b/src/components/map/GeoObjectMarker.tsx
new file mode 100644
index 0000000..e48d93e
--- /dev/null
+++ b/src/components/map/GeoObjectMarker.tsx
@@ -0,0 +1,40 @@
+import React from 'react';
+import { GeoObject } from '../../types/game';
+import { Box, Trophy, Gift } from 'lucide-react';
+
+interface GeoObjectMarkerProps {
+  geoObject: GeoObject;
+  onClick?: () => void;
+}
+
+const GeoObjectMarker: React.FC<GeoObjectMarkerProps> = ({
+  geoObject,
+  onClick,
+}) => {
+  const getIcon = () => {
+    switch (geoObject.type) {
+      case 'reward':
+        return <Trophy className="w-6 h-6 text-yellow-500" />;
+      case 'powerup':
+        return <Gift className="w-6 h-6 text-blue-500" />;
+      default:
+        return <Box className="w-6 h-6 text-purple-500" />;
+    }
+  };
+
+  return (
+    <div
+      className="cursor-pointer transform hover:scale-110 transition-transform"
+      onClick={onClick}
+    >
+      <div className="relative">
+        {getIcon()}
+        <div className="absolute -bottom-4 left-1/2 transform -translate-x-1/2 bg-black bg-opacity-75 px-2 py-1 rounded text-xs text-white whitespace-nowrap">
+          {geoObject.metadata.name || geoObject.type}
+        </div>
+      </div>
+    </div>
+  );
+};
+
+export default GeoObjectMarker;
diff --git a/src/components/navigation/NavigationMenu.tsx b/src/components/navigation/NavigationMenu.tsx
index 98cb906..abf2756 100644
--- a/src/components/navigation/NavigationMenu.tsx
+++ b/src/components/navigation/NavigationMenu.tsx
@@ -29,10 +29,10 @@ const NavigationMenu: React.FC<NavigationMenuProps> = ({
   ];
 
   const handleShoot = () => {
-    if (!location) {
-      console.error('Missing location');
-      return;
-    }
+    // if (!location) {
+    //   console.error('Missing location');
+    //   return;
+    // }
 
     try {
       shoot(location, heading);
diff --git a/src/context/GameContext.tsx b/src/context/GameContext.tsx
index d956cb9..331fe58 100644
--- a/src/context/GameContext.tsx
+++ b/src/context/GameContext.tsx
@@ -8,7 +8,6 @@ import React, {
   useCallback,
 } from 'react';
 import { WebSocketService } from '../services/WebSocketService';
-import { locationService } from '../services/LocationService';
 import {
   GameMessage,
   Player,
@@ -20,6 +19,8 @@ import {
   GeoObject,
 } from '../types/game';
 import { generateTemporaryId } from '../utils/uuid';
+import { HitValidationService } from '../services/HitValidationService';
+import { PlayerStats } from '../types/player';
 
 interface GameState {
   players: Player[];
@@ -65,9 +66,9 @@ const INITIAL_STATE: GameState = {
   gameScore: { hits: 0, kills: 0 },
   playerId: null,
   isAlive: true,
-  currentLives: 10,
+  currentLives: 0,
   maxLives: 10,
-  currentAmmo: 30,
+  currentAmmo: 0,
   maxAmmo: 30,
   isReloading: false,
   droneTimer: null,
@@ -81,47 +82,6 @@ const INITIAL_STATE: GameState = {
 const RELOAD_TIME = 3000;
 const RESPAWN_TIME = 60000;
 
-// MARK: -  Math utilities
-const toRadians = (degrees: number): number => (degrees * Math.PI) / 180;
-const toDegrees = (radians: number): number => (radians * 180) / Math.PI;
-
-const calculateDistance = (from: LocationData, to: LocationData): number => {
-  const R = 6371e3;
-  const φ1 = toRadians(from.latitude);
-  const φ2 = toRadians(to.latitude);
-  const Δφ = toRadians(to.latitude - from.latitude);
-  const Δλ = toRadians(to.longitude - from.longitude);
-
-  const a =
-    Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
-    Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
-
-  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
-  return R * c;
-};
-
-const calculateBearing = (from: LocationData, to: LocationData): number => {
-  const φ1 = toRadians(from.latitude);
-  const φ2 = toRadians(to.latitude);
-  const Δλ = toRadians(to.longitude - from.longitude);
-
-  const y = Math.sin(Δλ) * Math.cos(φ2);
-  const x =
-    Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
-
-  const θ = Math.atan2(y, x);
-  return (toDegrees(θ) + 360) % 360;
-};
-
-const calculateDamage = (
-  distance: number,
-  maxRange: number,
-  baseDamage: number
-): number => {
-  const damageFalloff = 1 - distance / maxRange;
-  return Math.max(baseDamage * damageFalloff, baseDamage);
-};
-
 // MARK: - Game Provider
 
 export const GameProvider: React.FC<{ children: React.ReactNode }> = ({
@@ -132,50 +92,7 @@ export const GameProvider: React.FC<{ children: React.ReactNode }> = ({
   const [, setGameStarted] = useState(false);
   const wsInstanceRef = useRef<WebSocketService | null>(null);
   const { location } = useLocationContext();
-
-  const validateHit = useCallback(
-    async (shooterLocation: LocationData, shooterHeading: number) => {
-      console.log('Validating hit:', shooterLocation, shooterHeading);
-
-      try {
-        const playerLocation = location
-          ? location
-          : await locationService.getCurrentLocation();
-        console.log('Player location:', playerLocation);
-        if (!playerLocation) {
-          return { isValid: false, damage: 0, distance: 0, deviation: 0 };
-        }
-
-        const MAX_RANGE = 500;
-        const MAX_ANGLE_ERROR = 30;
-        const BASE_DAMAGE = 1;
-
-        const distance = calculateDistance(shooterLocation, playerLocation);
-
-        if (distance > MAX_RANGE) {
-          return { isValid: false, damage: 0, distance, deviation: 0 };
-        }
-
-        const actualBearing = calculateBearing(shooterLocation, playerLocation);
-        let angleDiff = Math.abs(shooterHeading - actualBearing);
-        if (angleDiff > 180) {
-          angleDiff = 360 - angleDiff;
-        }
-
-        const deviation = distance * Math.tan(toRadians(angleDiff));
-        const isValid = angleDiff <= MAX_ANGLE_ERROR;
-        const damage = isValid
-          ? calculateDamage(distance, MAX_RANGE, BASE_DAMAGE)
-          : 0;
-
-        return { isValid, damage, distance, deviation };
-      } catch (error) {
-        console.error('Error fetching location:', error);
-        return { isValid: false, damage: 0, distance: 0, deviation: 0 };
-      }
-    },
-    [location]
-  );
+  const hitValidationService = HitValidationService.getInstance();
 
   // MARK: - updateGameScore
 
@@ -266,7 +183,7 @@ export const GameProvider: React.FC<{ children: React.ReactNode }> = ({
     });
   }, []);
 
-  const handleShot = useCallback(
+  const handleShoot = useCallback(
     async (
       message: GameMessage,
       shootData: ShootData,
@@ -277,9 +194,10 @@ export const GameProvider: React.FC<{ children: React.ReactNode }> = ({
       }
 
       console.log('Handling shot:', shootData);
-      const hitValidation = await validateHit(
+      const hitValidation = await hitValidationService.validateHit(
         shootData.location!,
-        shootData.heading
+        shootData.heading,
+        location
       );
       const type = hitValidation.isValid
         ? MessageType.HIT_CONFIRMED
@@ -304,7 +222,7 @@ export const GameProvider: React.FC<{ children: React.ReactNode }> = ({
       wsInstance.send(shootMessage);
       handleHit(hitValidation.damage);
     },
-    [state.playerId, validateHit, handleHit]
+    [state.playerId, handleHit, hitValidationService, location]
   );
 
   const handleGeoObjectUpdate = useCallback((message: GameMessage) => {
@@ -345,9 +263,28 @@ export const GameProvider: React.FC<{ children: React.ReactNode }> = ({
       }
 
       switch (message.type) {
+        case MessageType.STATS:
+          console.log('Received STATS: ', message);
+          if (message.data && message.playerId === state.playerId) {
+            setState((prev) => ({
+              ...prev,
+              currentAmmo:
+                (message.data as PlayerStats).currentAmmo ?? prev.currentAmmo,
+              currentLives:
+                (message.data as PlayerStats).currentLives ?? prev.currentLives,
+              gameScore: {
+                hits: (message.data as PlayerStats).hits ?? prev.gameScore.hits,
+                kills:
+                  (message.data as PlayerStats).kills ?? prev.gameScore.kills,
+              },
+              isReloading: false,
+            }));
+          }
+          break;
+
         case MessageType.SHOOT:
           if (message.data && message.playerId !== state.playerId) {
-            await handleShot(message, message.data as ShootData, wsInstance);
+            await handleShoot(message, message.data as ShootData, wsInstance);
             setState((prev) => ({
               ...prev,
               players: prev.players.map((player) =>
@@ -470,7 +407,7 @@ export const GameProvider: React.FC<{ children: React.ReactNode }> = ({
           break;
       }
     },
-    [state, location, handleShot, resetDroneTimer, handleHit]
+    [state, location, handleShoot, resetDroneTimer, handleHit]
   );
 
   // MARK: - showReward
@@ -537,141 +474,136 @@ export const GameProvider: React.FC<{ children: React.ReactNode }> = ({
     // };
   }, [state.playerId, handleGameMessage]);
 
-  // MARK: - handleAdReward
+  // MARK: - sendReloadRequest
 
-  const handleAdReward = useCallback(() => {
-    switch (state.showAdModal) {
-      case 'ammo':
-        setState((prev) => ({
-          ...prev,
-          currentAmmo: prev.maxAmmo,
-          isReloading: false,
-          showAdModal: null,
-        }));
-        break;
-      case 'lives':
-        setState((prev) => ({
-          ...prev,
-          currentLives: prev.maxLives,
-          isAlive: true,
-          showAdModal: null,
-        }));
-        break;
-    }
-  }, [state.showAdModal]);
+  const sendReloadRequest = useCallback(() => {
+    const wsInstance = WebSocketService.getInstance();
 
-  // MARK: - closeAdModal
+    // Send reload message to server only once
+    const reloadMessage: GameMessage = {
+      type: MessageType.RELOAD,
+      playerId: state.playerId,
+    };
 
-  const closeAdModal = useCallback(() => {
-    console.log('Closing ad modal');
-    setState((prev) => ({
-      ...prev,
-      showAdModal: null,
-    }));
+    wsInstance.send(reloadMessage);
+  }, [state.playerId]);
+
+  // MARK: - performReload
+
+  const performReload = useCallback(() => {
+    if (state.isReloading) {
+      console.log('⚠️ Already reloading');
+      return;
+    }
 
     console.log('⏳ Starting reload process');
     setState((prev) => ({ ...prev, isReloading: true }));
 
+    // Complete reload after delay
     setTimeout(() => {
-      setState((prev) => ({
-        ...prev,
-        currentAmmo: prev.maxAmmo,
-        isReloading: false,
-      }));
+      console.log('📡 Sent reload message to server');
+      sendReloadRequest();
     }, RELOAD_TIME);
-  }, [state.isReloading, state.currentAmmo]);
+  }, [state.isReloading, state.playerId, state.maxAmmo, sendReloadRequest]);
+
+  // MARK: - handleAdReward
 
-  // MARK: reload
+  const handleAdReward = useCallback(() => {
+    setState((prev) => {
+      switch (prev.showAdModal) {
+        case 'ammo':
+          performReload();
+          return {
+            ...prev,
+            showAdModal: null,
+          };
 
-  const reload = useCallback(() => {
-    console.log('🔄 Reload function called', {
-      currentAmmo: state.currentAmmo,
-      isReloading: state.isReloading,
-      timestamp: new Date().toISOString(),
+        case 'lives':
+          return {
+            ...prev,
+            currentLives: prev.maxLives,
+            isAlive: true,
+            showAdModal: null,
+          };
+        default:
+          return prev;
+      }
     });
+  }, [performReload]);
 
-    if (!state.isReloading) {
-      // Only show ad modal or start reload when ammo is fully depleted
-      if (state.currentAmmo <= 1) {
-        console.log('📉 Zero ammo, showing ad modal');
-        setState((prev) => ({ ...prev, showAdModal: 'ammo' }));
-        return;
+  // MARK: - closeAdModal
+
+  const closeAdModal = useCallback(() => {
+    setState((prev) => {
+      if (prev.showAdModal === 'ammo') {
+        performReload();
+        return {
+          ...prev,
+          showAdModal: null,
+          isReloading: true,
+        };
       }
 
-      // Don't start reloading unless ammo is very low (let's say 1 or 0)
-      if (state.currentAmmo > 1) {
-        console.log(
-          '🎯 Sufficient ammo, no need to reload:',
-          state.currentAmmo
-        );
-        return;
+      if (prev.showAdModal === 'lives') {
+        setTimeout(() => {
+          setState((prev) => ({
+            ...prev,
+            currentLives: prev.maxLives,
+            isAlive: true,
+          }));
+        }, RESPAWN_TIME);
       }
 
-      console.log('⏳ Starting reload process');
-      setState((prev) => ({ ...prev, isReloading: true }));
+      return {
+        ...prev,
+        showAdModal: null,
+      };
+    });
+  }, [performReload]);
 
-      setTimeout(() => {
-        setState((prev) => ({
-          ...prev,
-          currentAmmo: prev.maxAmmo,
-          isReloading: false,
-        }));
-      }, RELOAD_TIME);
-    }
-  }, [state.isReloading, state.currentAmmo]);
+  // Rename reload to match its usage as a public method
+  const reload = performReload;
 
   // MARK: - shoot
 
   const shoot = useCallback(
     (location: LocationData, heading: number) => {
-      console.log(
-        '🔫 Shoot function called with current ammo:',
-        state.currentAmmo
-      );
-
       if (!state.isAlive || !state.playerId) {
         console.log('❌ Shoot blocked - not alive or no player ID');
         return;
       }
 
-      // Check current ammo before decreasing
-      console.log('📊 Pre-shoot ammo check:', {
-        currentAmmo: state.currentAmmo,
-        isReloading: state.isReloading,
-      });
+      // Check if already reloading
+      if (state.isReloading) {
+        console.log('⏳ Blocked - currently reloading');
+        return;
+      }
 
+      // Check ammo and show modal if needed
       if (state.currentAmmo <= 0) {
         console.log('🚫 No ammo left, showing ad modal');
         setState((prev) => ({ ...prev, showAdModal: 'ammo' }));
         return;
       }
 
-      if (state.isReloading) {
-        console.log('⏳ Blocked - currently reloading');
-        return;
-      }
-
       // Update ammo count
       setState((prev) => {
-        const newAmmo = prev.currentAmmo - 1;
-        console.log('🔄 Decreasing ammo', {
-          previous: prev.currentAmmo,
-          new: newAmmo,
-          timestamp: new Date().toISOString(),
-        });
-
-        // Only trigger reload when ammo is critically low
-        if (newAmmo <= 1) {
-          console.log('📉 Low ammo, triggering reload');
-          setTimeout(() => reload(), 0);
+        const newAmmo = Math.max(0, prev.currentAmmo - 1);
+        // Show ad modal when ammo depleted
+        if (newAmmo === 0) {
+          return {
+            ...prev,
+            currentAmmo: newAmmo,
+            showAdModal: 'ammo',
+          };
         }
-
         return {
           ...prev,
           currentAmmo: newAmmo,
         };
       });
 
+      // Send shoot message
       const wsInstance = WebSocketService.getInstance();
       const shootData: ShootData = {
         playerId: state.playerId,
@@ -681,39 +613,15 @@ export const GameProvider: React.FC<{ children: React.ReactNode }> = ({
         distance: 0,
       };
 
-      const message: GameMessage = {
+      wsInstance.send({
         type: MessageType.SHOOT,
         playerId: state.playerId,
         data: shootData,
-      };
-
-      if (location) {
-        wsInstance.send(message);
-        console.log('✅ Shot fired, message sent');
-      }
+      });
     },
-    [
-      state.isAlive,
-      state.isReloading,
-      state.currentAmmo,
-      state.playerId,
-      reload,
-    ]
+    [state.isAlive, state.isReloading, state.currentAmmo, state.playerId]
   );
 
-  const notifyNewGeoObject = (geoObjects: GeoObject[]) => {
-    setState((prev) => ({
-      ...prev,
-      geoObjects: [...prev.geoObjects, ...geoObjects],
-    }));
-  };
-
-  const handleGeoObjectHit = (geoObject: GeoObject) => {
-    document.dispatchEvent(
-      new CustomEvent('geoObjectHit', { detail: geoObject })
-    );
-  };
-
   const handleGeoObjectShootConfirmed = (geoObject: GeoObject) => {
     document.dispatchEvent(
       new CustomEvent('geoObjectShootConfirmed', { detail: geoObject })
diff --git a/src/pages/Map.tsx b/src/pages/Map.tsx
index d590758..db5642e 100644
--- a/src/pages/Map.tsx
+++ b/src/pages/Map.tsx
@@ -5,6 +5,7 @@ import { useLocationContext } from '../context/LocationContext';
 import { useGameContext } from '../context/GameContext';
 import { createRoot } from 'react-dom/client';
 import PlayerMarker from '../components/map/PlayerMarker';
+import GeoObjectMarker from '../components/map/GeoObjectMarker';
 import { WebSocketService } from '../services/WebSocketService';
 import { MessageType } from '../types/game';
 
@@ -12,17 +13,18 @@ mapboxgl.accessToken = process.env.REACT_APP_MAP_BOX;
 
 const containerStyle: React.CSSProperties = {
   width: '100%',
-  height: 'calc(100% - 170px)', // Deduct 80px from the total height
+  height: 'calc(100% - 170px)',
   position: 'relative',
-  marginBottom: '170px', // Fixed spacing at the bottom
+  marginBottom: '170px',
 };
 
 const Map = () => {
   const mapContainerRef = useRef<HTMLDivElement | null>(null);
   const mapRef = useRef<mapboxgl.Map | null>(null);
   const markerRefs = useRef<{ [key: string]: mapboxgl.Marker }>({});
+  const geoObjectMarkerRefs = useRef<{ [key: string]: mapboxgl.Marker }>({});
   const { location } = useLocationContext();
-  const { players, playerId } = useGameContext();
+  const { players, playerId, geoObjects } = useGameContext();
 
   // Initialize map once
   useEffect(() => {
@@ -73,16 +75,35 @@ const Map = () => {
 
     return () => {
       Object.values(markerRefs.current).forEach((marker) => marker.remove());
+      Object.values(geoObjectMarkerRefs.current).forEach((marker) =>
+        marker.remove()
+      );
       map.remove();
       mapRef.current = null;
     };
-  }, []); // Empty dependency array - only run once
+  }, []);
 
-  // Handle other players updates - only when players array changes
+  // Update current player position
+  useEffect(() => {
+    if (!location || !markerRefs.current['current']) return;
+
+    markerRefs.current['current'].setLngLat([
+      location.longitude,
+      location.latitude,
+    ]);
+
+    if (mapRef.current) {
+      mapRef.current.easeTo({
+        center: [location.longitude, location.latitude],
+        duration: 1000,
+      });
+    }
+  }, [location]);
+
+  // Handle other players updates
   useEffect(() => {
     if (!mapRef.current) return;
 
-    // Update or create markers for other players
     players.forEach((player) => {
       if (!player.location || player.playerId === playerId) return;
 
@@ -117,7 +138,90 @@ const Map = () => {
         delete markerRefs.current[markerId];
       }
     });
-  }, [players]); // Only react to players array changes
+  }, [players]);
+
+  // Handle GeoObjects updates
+  useEffect(() => {
+    if (!mapRef.current) return;
+
+    console.log('GeoObjects:', geoObjects); // Debugging geoObjects data
+
+    geoObjects.forEach((geoObject) => {
+      const markerId = geoObject.id;
+      const markerPosition = [
+        geoObject.coordinate.longitude,
+        geoObject.coordinate.latitude,
+      ];
+
+      console.log(`Creating GeoObject: ${markerId}`, markerPosition);
+      const markerElement = document.createElement('div');
+      const root = createRoot(markerElement);
+      root.render(
+        <GeoObjectMarker
+          geoObject={geoObject}
+          onClick={() => {
+            if (mapRef.current) {
+              mapRef.current.flyTo({
+                center: markerPosition,
+                zoom: 18,
+                duration: 1000,
+              });
+            }
+          }}
+        />
+      );
+
+      geoObjectMarkerRefs.current[markerId] = new mapboxgl.Marker({
+        element: markerElement,
+      })
+        .setLngLat(markerPosition)
+        .addTo(mapRef.current);
+    });
+
+    // Clean-up markers for removed GeoObjects
+    Object.keys(geoObjectMarkerRefs.current).forEach((markerId) => {
+      if (!geoObjects.find((obj) => obj.id === markerId)) {
+        console.log(`Removing GeoObject: ${markerId}`);
+        geoObjectMarkerRefs.current[markerId].remove();
+        delete geoObjectMarkerRefs.current[markerId];
+      }
+    });
+  }, [geoObjects]);
+
+  useEffect(() => {
+    if (!mapRef.current) return;
+
+    const bounds = new mapboxgl.LngLatBounds();
+
+    // Include current player location
+    if (location) {
+      bounds.extend([location.longitude, location.latitude]);
+    }
+
+    // Include other players' locations
+    players.forEach((player) => {
+      if (player.location && player.playerId !== playerId) {
+        bounds.extend([player.location.longitude, player.location.latitude]);
+      }
+    });
+
+    // Include GeoObjects locations
+    geoObjects.forEach((geoObject) => {
+      bounds.extend([
+        geoObject.coordinate.longitude,
+        geoObject.coordinate.latitude,
+      ]);
+    });
+
+    // Fit map to the calculated bounds
+    if (!bounds.isEmpty()) {
+      mapRef.current.fitBounds(bounds, {
+        padding: 50, // Add padding around the edges of the viewport
+        maxZoom: 15, // Optional: Limit the zoom level
+        duration: 1000, // Animation duration in milliseconds
+      });
+    }
+  }, [location, players, geoObjects]);
 
   if (!location) {
     return (
@@ -125,7 +229,7 @@ const Map = () => {
         <div className="text-center">
           <p className="text-xl">Getting your location...</p>
           <p className="text-sm text-gray-400 mt-2">
-            Check locations services if it takes too long
+            Check location services if it takes too long
           </p>
         </div>
       </div>
diff --git a/src/services/GeoObjectManager.ts b/src/services/GeoObjectManager.ts
index 4befeac..0580ef6 100644
--- a/src/services/GeoObjectManager.ts
+++ b/src/services/GeoObjectManager.ts
@@ -1,6 +1,6 @@
 import * as THREE from 'three';
 import { GeoObject, LocationData } from '../types/game';
-import { locationService } from './LocationService';
+import { calculateDistance, calculateBearing } from '../utils/maths';
 
 export class GeoObjectManager {
   private static instance: GeoObjectManager;
@@ -32,7 +32,7 @@ export class GeoObjectManager {
     this.onHitCallback = callback;
   }
 
-  async spawnGeoObject(geoObject: GeoObject) {
+  async spawnGeoObject(geoObject: GeoObject, location: LocationData) {
     if (!this.scene) {
       console.error('Scene not initialized');
       return;
@@ -41,11 +41,7 @@ export class GeoObjectManager {
     console.log('Spawning GeoObject:', geoObject);
 
     try {
-      const userLocation = await locationService.getCurrentLocation();
-      const position = this.calculatePosition(
-        geoObject.coordinate,
-        userLocation
-      );
+      const position = this.calculatePosition(geoObject.coordinate, location);
 
       const node = this.createNode(geoObject, position);
       this.objects.set(geoObject.id, geoObject);
@@ -58,7 +54,7 @@ export class GeoObjectManager {
         id: geoObject.id,
         type: geoObject.type,
         position,
-        userLocation,
+        location,
         objectLocation: geoObject.coordinate,
       });
     } catch (error) {
@@ -111,14 +107,8 @@ export class GeoObjectManager {
     objectLocation: LocationData,
     userLocation: LocationData
   ): THREE.Vector3 {
-    const distance = locationService.calculateDistance(
-      userLocation,
-      objectLocation
-    );
-    const bearing = locationService.calculateBearing(
-      userLocation,
-      objectLocation
-    );
+    const distance = calculateDistance(userLocation, objectLocation);
+    const bearing = calculateBearing(userLocation, objectLocation);
 
     // Convert polar coordinates to Cartesian
     const radians = (bearing * Math.PI) / 180;
diff --git a/src/services/HitValidationService.ts b/src/services/HitValidationService.ts
index 9d143dc..89955f5 100644
--- a/src/services/HitValidationService.ts
+++ b/src/services/HitValidationService.ts
@@ -3,6 +3,7 @@
 
 import { LocationData } from '../types/game';
 import { LocationService } from './LocationService';
+import { calculateDistance, calculateBearing, toRadians } from '../utils/maths';
 
 interface HitValidation {
   isValid: boolean;
@@ -14,7 +15,7 @@ interface HitValidation {
 export class HitValidationService {
   private static instance: HitValidationService;
   private locationService: LocationService;
-  
+
   private readonly MAX_RANGE = 500; // meters
   private readonly MAX_ANGLE_ERROR = 30; // degrees
   private readonly BASE_DAMAGE = 1;
@@ -35,21 +36,30 @@ export class HitValidationService {
     shooterHeading: number,
     target: LocationData
   ): HitValidation {
-    const distance = this.locationService.calculateDistance(shooter, target);
-    
+    if (!target) {
+      return {
+        isValid: false,
+        damage: 0,
+        distance: 0,
+        deviation: 0,
+      };
+    }
+
+    const distance = calculateDistance(shooter, target);
+
     // Check if target is in range
     if (distance > this.MAX_RANGE) {
       return {
         isValid: false,
         damage: 0,
         distance,
-        deviation: 0
+        deviation: 0,
       };
     }
 
     // Calculate actual bearing to target
-    const actualBearing = this.locationService.calculateBearing(shooter, target);
-    
+    const actualBearing = calculateBearing(shooter, target);
+
     // Calculate angle difference
     let angleDiff = Math.abs(shooterHeading - actualBearing);
     if (angleDiff > 180) {
@@ -57,7 +67,7 @@ export class HitValidationService {
     }
 
     // Calculate deviation in meters
-    const deviation = distance * Math.tan(this.locationService.toRadians(angleDiff));
+    const deviation = distance * Math.tan(toRadians(angleDiff));
 
     // Validate hit based on angle difference
     const isValid = angleDiff <= this.MAX_ANGLE_ERROR;
@@ -69,13 +79,13 @@ export class HitValidationService {
       isValid,
       damage,
       distance,
-      deviation
+      deviation,
     };
   }
 
   private calculateDamage(distance: number): number {
     // Damage decreases linearly with distance
-    const damageFalloff = 1 - (distance / this.MAX_RANGE);
+    const damageFalloff = 1 - distance / this.MAX_RANGE;
     return Math.max(this.BASE_DAMAGE * damageFalloff, this.BASE_DAMAGE);
   }
-}
\ No newline at end of file
+}
diff --git a/src/services/LocationService.ts b/src/services/LocationService.ts
index 819a2bd..1e2a3ae 100644
--- a/src/services/LocationService.ts
+++ b/src/services/LocationService.ts
@@ -1,5 +1,4 @@
-// src/services/LocationService.ts
-// Handles location calculations and validations
+import { calculateDistance } from '../utils/maths';
 
 export interface LocationData {
   latitude: number;
@@ -20,51 +19,15 @@ export class LocationService {
     return LocationService.instance;
   }
 
-  calculateDistance(from: LocationData, to: LocationData): number {
-    const R = 6371e3; // Earth's radius in meters
-    const φ1 = this.toRadians(from.latitude);
-    const φ2 = this.toRadians(to.latitude);
-    const Δφ = this.toRadians(to.latitude - from.latitude);
-    const Δλ = this.toRadians(to.longitude - from.longitude);
-
-    const a =
-      Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
-      Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
-
-    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
-    return R * c;
-  }
-
-  calculateBearing(from: LocationData, to: LocationData): number {
-    const φ1 = this.toRadians(from.latitude);
-    const φ2 = this.toRadians(to.latitude);
-    const Δλ = this.toRadians(to.longitude - from.longitude);
-
-    const y = Math.sin(Δλ) * Math.cos(φ2);
-    const x =
-      Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
-
-    const θ = Math.atan2(y, x);
-    return (this.toDegrees(θ) + 360) % 360;
-  }
-
   validateHit(
     shooter: LocationData,
     target: LocationData,
     maxRange: number
   ): boolean {
-    const distance = this.calculateDistance(shooter, target);
+    const distance = calculateDistance(shooter, target);
     return distance <= maxRange;
   }
 
-  toRadians(degrees: number): number {
-    return (degrees * Math.PI) / 180;
-  }
-
-  private toDegrees(radians: number): number {
-    return (radians * 180) / Math.PI;
-  }
-
   getCurrentLocation(): Promise<LocationData> {
     console.log('Fetching location');
     return new Promise((resolve, reject) => {
diff --git a/src/types/game.ts b/src/types/game.ts
index d265398..23a1602 100644
--- a/src/types/game.ts
+++ b/src/types/game.ts
@@ -50,11 +50,13 @@ export type GameScore = {
 export enum MessageType {
   WEBSOCKET_CONNECTED = 'websocket_connected',
   JOIN = 'join',
+  STATS = 'stats',
   SHOOT = 'shoot',
   SHOOT_CONFIRMED = 'shootConfirmed',
   HIT = 'hit',
   KILL = 'kill',
   HIT_CONFIRMED = 'hitConfirmed',
+  RELOAD = 'reload',
   LEAVE = 'leave',
   ANNOUNCED = 'announced',
   NEW_DRONE = 'newDrone',
@@ -92,7 +94,7 @@ export type GameMessageData = {
 export type GameMessage = {
   type: MessageType;
   playerId: string;
-  data: GameMessageData;
+  data?: GameMessageData;
   senderId?: string;
   pushToken?: string;
 };
diff --git a/src/types/location.ts b/src/types/location.ts
index e69de29..d1d69b0 100644
--- a/src/types/location.ts
+++ b/src/types/location.ts
@@ -0,0 +1,6 @@
+export interface Location {
+  latitude: number;
+  longitude: number;
+  accuracy: number;
+  altitude: number;
+}
diff --git a/src/types/player.ts b/src/types/player.ts
index e69de29..29855cf 100644
--- a/src/types/player.ts
+++ b/src/types/player.ts
@@ -0,0 +1,31 @@
+import { Location } from './location'; // Replace with your actual location type if applicable
+
+export interface PlayerStats {
+  kills: number;
+  hits: number;
+  deaths: number;
+  droneHits: number;
+  survivalStart: Date | null;
+  accuracy: number;
+  shoots: number;
+  currentLives: number;
+  currentAmmo: number;
+}
+
+export interface Player {
+  playerId: string; // Always required
+  kind?: string; // Defaults to 'player'
+  walletAddress?: string | null;
+  nickname?: string | null;
+  passwordHash?: string | null;
+  passwordSalt?: string | null;
+  email?: string | null;
+  pushToken?: string | null;
+  pushTokenUpdatedAt?: Date | null;
+  stats: PlayerStats; // Nested stats object
+  lastActive: Date; // Defaults to current date
+  mintedBalance: number; // Defaults to 0
+  pendingBalance: number; // Defaults to 0
+  lastUpdate: Date; // Defaults to current date
+  location?: Location; // Replace `Location` with your actual type
+}
diff --git a/src/utils/maths.ts b/src/utils/maths.ts
new file mode 100644
index 0000000..f2e5ffe
--- /dev/null
+++ b/src/utils/maths.ts
@@ -0,0 +1,48 @@
+import { LocationData } from '../types/game';
+
+// MARK: -  Math utilities
+export const toRadians = (degrees: number): number => (degrees * Math.PI) / 180;
+export const toDegrees = (radians: number): number => (radians * 180) / Math.PI;
+
+export const calculateDistance = (
+  from: LocationData,
+  to: LocationData
+): number => {
+  const R = 6371e3;
+  const φ1 = toRadians(from.latitude);
+  const φ2 = toRadians(to.latitude);
+  const Δφ = toRadians(to.latitude - from.latitude);
+  const Δλ = toRadians(to.longitude - from.longitude);
+
+  const a =
+    Math.sin(Δφ / 2) * Math.sin(Δφ / 2) +
+    Math.cos(φ1) * Math.cos(φ2) * Math.sin(Δλ / 2) * Math.sin(Δλ / 2);
+
+  const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
+  return R * c;
+};
+
+export const calculateBearing = (
+  from: LocationData,
+  to: LocationData
+): number => {
+  const φ1 = toRadians(from.latitude);
+  const φ2 = toRadians(to.latitude);
+  const Δλ = toRadians(to.longitude - from.longitude);
+
+  const y = Math.sin(Δλ) * Math.cos(φ2);
+  const x =
+    Math.cos(φ1) * Math.sin(φ2) - Math.sin(φ1) * Math.cos(φ2) * Math.cos(Δλ);
+
+  const θ = Math.atan2(y, x);
+  return (toDegrees(θ) + 360) % 360;
+};
+
+export const calculateDamage = (
+  distance: number,
+  maxRange: number,
+  baseDamage: number
+): number => {
+  const damageFalloff = 1 - distance / maxRange;
+  return Math.max(baseDamage * damageFalloff, baseDamage);
+};
